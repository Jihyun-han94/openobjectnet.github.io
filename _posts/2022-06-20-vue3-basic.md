---
title:  "Vue3 기초 문법 정리"
search: false
categories: 
  - Vue
toc: true  
tags:
  - Vue
author: 김도겸
---
<br>
# Intro
안녕하세요. 김도겸입니다. <br>
Vue3 기본 개념 및 기초 문법과 핵심 개념인 compostition api에 대해 공부한 내용들을 간단히 정리해보았습니다.

<br><br>

# 0. 프로젝트 생성
다음과 같은 코드로 vue-cli를 install 후 vue create 명령어로 프로젝트를 간단하게 생성합니다.
```
npm install -g @vue/cli  # 또는 yarn global add @vue/cli
vue create hello-vue3
``` 

<br>

# 1. 인스턴스

## 인스턴스 개념
인스턴스란 뷰의 시작이 되는 것으로  모든 vue 앱을 만들 때 필수로 생성해야 하는 코드입니다. <br>
인스턴스 안에는 미리 정의되어 있는 속성과 메서드들이 있기 때문에 이 기능들을 이용하여 효과적인<br>
화면 구현이 가능합니다. <br>


- 가장 기초적인 vue 생성 및 data binding 예시입니다.

```html
<div id="counter">
  Counter: {% raw %}{{ counter }}{% endraw %}
</div>
```

```javascript
const Counter = {
  data() {
    return {
      counter: 0
    }
  }
}

Vue.createApp(Counter).mount('#counter')  
``` 
> html 코드로 먼저 해당 화면의 틀을 만든 후, vue 인스턴스를 생성하여 속성을 설정합니다.<br>
> data를 화면에 표시하기 위해서는 위 사진에서 보이는 것과 같이 {% raw %}{{ data명 }}{% endraw %}를 사용합니다.


## 인스턴스 LifeCycle
인스턴스 LifeCycle(생명주기)이란 뷰의 인스턴스가 생성되어 소멸되기까지 거치는 과정을 의미합니다.

vue는 다음과 같은 과정으로 진행됩니다.
![lifecycle](/assets/images/vue-dogyeom/lifecycle.png)
<br>

### 라이프 사이클 훅
라이프 사이클 훅으로 인스턴스의 특정 시점에 원하는 로직을 구현 할 수 있습니다.<br>
따라서 반드시 라이프 사이클에 대한 이해가 필요합니다.

```javascript
Vue.createApp({
  data() {
    return { count: 1 }
  },
  created() {
    // `this` points to the vm instance
    console.log('count is: ' + this.count) // => "count is: 1"
  }
})
```
필요한 lifecycle 훅을 입력하여 해당 주기에서 실행될 코드를 작성합니다.

<br>

# 2. 템플릿 문법

## 보간법
* <b>문자열</b>

    데이터 바인딩의 가장 기초가 되는 방식입니다. <br>
    Mustache(이중 중괄호)기법을 사용하여 문자열을 바인딩 할 수 있습니다.
    ```html
    <span>메시지:{% raw %}{{ msg }}{% endraw %}</span>
    ```
    msg 데이터가 변경될 경우 갱신됩니다. 만약 데이터가 변경되어도 갱신되지 않기를 원한다면, v-once를 사용합니다.  
    ```html
    <span v-once>결코 변하지 않을 것입니다: {% raw %}{{ msg }}{% endraw %}</span>
    ```
<br>

* <b>원시 HTML</b> 
 
    이중 중괄호는 일반 텍스트로 바인딩 되므로 만약 html을 출력하기 위해서는 v-html을 사용해야합니다.

    ```html
    <p>이중 중괄호 사용: {{ rawHtml }}</p>
    <p>v-html 디렉티브 사용: <span v-html="rawHtml"></span></p>
    ```

    ```javascript
    data() {
      return {
        rawHtml: '<span style="color: red">This should be red.</span>'
      }
    }
    ```
<br>

* <b>속성</b>  
    속성을 부여할 때는 이중 중괄호 기법을 사용 할 수 없으므로 v-bind를 사용합니다. <br>
    기본적인 사용방법만 정리하고, 다른 여러가지 속성은 추가적으로 설명드리겠습니다.

    ```html
    <div v-bind:id="dynamicId"></div>
    <button v-bind:disabled="isButtonDisabled">Button</button>
    ```
    > v-bind:id는 id를 부여하고, v-bind:disabled는 boolean값인 isButtonDisabled의 값에 따라<br>
    > button의 활성화 여부를 결정합니다.
<br> 

* <b>JavaScript 표현식 사용</b>  

    간단한 속성 키들을 템플릿에 바인딩하는 방법이 있으나, 데이터 바인딩 시에 javascript 표현식 기능을 사용 할 수 있습니다.
    ```html
      <div>{% raw %}{{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('')}}{% endraw %}</div>
      <div v-bind:id="'list-' + id"></div>
    ```

    하지만 바인딩에서는 반드시 하나의 단일 표현식만 포함해야됩니다.<br> 
    그렇기 때문에 다음과 같이 작성하면 안됩니다.
    
    ```html
    <!-- 아래는 문장입니다. 표현식이 아닙니다. -->
    {% raw %}{{ var a = 1 }}{% endraw %}

    <!-- 조건문은 작동하지 않습니다. 삼항 연산자를 사용해야 합니다. -->
    {% raw %}{{ if (ok) { return message } }}{% endraw %}
    ```
<br>

* <b>동적 전달인자</b>

    js표현식을 활용하여 대괄호로 묶어 디렉티브 전달인자로 사용 할 수 있습니다.

    ```html
    <a v-bind:[attributeName]="url"> ... </a>
    ```

    attributeName의 값이 변경되면 속성이 변경됩니다.<br>


> 다음과 같이 ' v- '로 시작하는 속성들을 디렉티브라고 합니다. <br>
> v-bind:[속성명]는 :[속성명]으로 축약해서 사용 가능하고, v-on:[속성명]은 @[속성명]으로 축약하여 사용 가능합니다.<br>

<br>

# 3. Data 속성 & methods

라이프 사이클 훅 파트에서의 코드를 보시면 data()라는 함수가 보입니다.<br>
이 함수는 하나의 객체를 반환하고, 반환한 객체의 데이터들은 모두 vue 반응형 시스템에 의해 변경이 감지되어<br> 컴포넌트 인스턴스의 $data에 저장된 후 화면에 반영됩니다.<br>

methods 옵션을 사용하여 컴포넌트에 필요한 메서드를 추가하여 사용 할 수 있습니다.


```javascript
const app = Vue.createApp({
  data() {
    return { count: 4 }
  },
  methods: {
    increment() {
      // `this`는 컴포넌트 인스턴스를 참조합니다.
      this.count++
    }
  }
})

const vm = app.mount('#app')

console.log(vm.count) // => 4

vm.increment()
// vm.count에 값을 할당하면 $data.count도 갱신됩니다.
console.log(vm.$data.count) // => 5
console.log(vm.count) // => 5
```
> 사용할 데이터는 this.{data명}을 활용하면 됩니다.

```html
<button @click="increment">Up vote</button>
<span :title="toTitleDate(date)">
  {{ formatDate(date) }}
</span>
```
위처럼 템플릿에서 메서드를 직접 호출하여 사용 할 수도 있습니다

<br>

# 4. computed & watch

computed와 watch는 모두 지정한 특정 대상이 변경될 경우 이에 반응하여 선언한 함수를 실행해주는 기능입니다.<br>
하지만 이 둘은 같다라고는 할 수 없습니다.

```html
<div id="demo">{{ fullName }}</div>
```

```javascript
const vm = Vue.createApp({
  data() {
    return {
      firstName: 'Foo',
      lastName: 'Bar'
    }
  },
  computed: {
    fullName() {
      return this.firstName + ' ' + this.lastName
    }
  }
}).mount('#demo')
```
computed는 firstName과 lastName이 변경이 될 때를 감지하여 이미 계산되어 있는 결과를 보여줍니다. <br>
종속 대상의 값이 변경되지 않는다면 컴포넌트가 리렌더링 되도 다시 실행되지 않습니다.
```javascript
const vm = Vue.createApp({
  data() {
    return {
      firstName: 'Foo',
      lastName: 'Bar',
      fullName: 'Foo Bar'
    }
  },
  watch: {
    firstName(val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName(val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
}).mount('#demo')
```
watch는 firstName과 lastName을 감시하며 변경될 때 fullName을 변경해줍니다.

쉽게 정리하자면 computed는 특정 값이 변경될 때만을 감지하여 반환하는 변수의 역할이 필요할 때 사용하는것이 좋다고 생각하고, 
watch 함수는 계속 값을 감시하여 어떤 로직이 실행되어야 할 때 트리거 역할을 해줄때 사용하는 것이 좋다고 생각합니다. 

<br>

# 5. v-bind (바인딩)
v-bind는 간편하게 view 영역에서 간편하게 data를 연결하기 위해서 사용합니다. <br>
v-bind를 주로 사용 할 수 있는 대표적인 속성은 style, class, src(이미지 바인딩), href(링크 바인딩)가 있습니다.

사용법은 생각보다 간단합니다. v-bind:{속성명}도 가능하고, v-bind를 생략한 채 :{속성명}으로도 사용 가능합니다.

간단한 코드 예제를 몇가지 보여드리겠습니다.

* <b>:class</b>
<br>

  <b>1) 객체로 전달하기</b>

  ```html
  <div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
  >
  </div>
  ```
  위와 같이 객체에 필드를 포함하는 형식으로 작성합니다.

  ```javascript
  data() {
    return {
      isActive: true,
      hasError: false
    }
  }
  ```
  객체에 포함된 데이터에 따라 다음과 같이 렌더링됩니다.

  ```html
  <div class="static active"></div>
  ```
  > <p style="font-size:20px"> isActive 또는 hasError가 변경되면 그에따라 클래스 목록이 업데이트됩니다.</p>

  ```html
  <div :class="classObject"></div>
  ```
  ```javascript
  data() {
    return {
      classObject: {
        active: true,
        'text-danger': false
      }
    }
  }
  ```
  :class에 객체를 선언하지 않고, data()에 객체를 선언하고 사용하여도 상관없습니다.

  > 해당 구문은 computed를 사용해도 바인딩이 가능합니다.

  <br>
  <b>2) 배열로 전달하기</b>

  ```html
  <div :class="[activeClass, errorClass]"></div>
  ```
  위와 같이 배열 형식으로 클래스 목록을 작성합니다.

  ```javascript
  data() {
  return {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
  ```
  배열에 포함된 데이터에 따라 다음과 같이 렌더링됩니다.

  ```html
  <div class="active text-danger"></div>
  ```

  추가적으로 조건부로 목록의 클래스를 전환하려면, 삼항 표현식을 사용하여 수행 할 수 있습니다.
  ```html
  <div :class="[isActive ? activeClass : '', errorClass]"></div>
  ```
  위와 같이 선언하면 isActive가 false일땐 errorClass만 적용되고, true일때는 activeClass를 추가로 적용됩니다.<br>
  만약 여러 조건부 클래스가 있어 보기에 너무 복잡해 보인다면, 
  ```html
  <div :class="[{ active: isActive }, errorClass]"></div>
  ```
  위와 같이 배열 구문 내에서 객체 구문을 사용해 비교적 보기 쉽게 선언 할 수 있습니다.

  <br>
  <b>3) 컴포넌트에서 클래스 추가하기</b>

  우선적으로 컴포넌트를 간단하게 만들어보겠습니다.<br>
  (컴포넌트의 자세한 사항은 컴포넌트 파트에서 설명드리도록 하겠습니다.)
  ```javascript
  const app = Vue.createApp({})

  app.component('my-component', {
    template: `<p class="foo bar">Hi!</p>`
  })
  ```
  
  ```html
  <div id="app">
    <my-component class="baz boo"></my-component>
  </div>
  ```

  위와 같이 컴포넌트를 선언하고, 클래스를 추가하게 되어 사용하게 되면

  ```html
  <p class="foo bar baz boo">Hi</p>
  ```
  위처럼 template 내에 선언한 foo, bar 클래스에 컴포넌트에 선언한 baz, boo 클래스까지 추가로 렌더링됩니다.
  > 이는 클래스 바인딩(:class)을 사용하여도 동일하게 작동됩니다.


* <b>:style</b>

  :style 사용법은 css를 사용하는 것과 매우 유사하기 때문에 매우 간단합니다.

  <b>1) 객체로 전달하기</b>

  객체로 전달하는 방법은 :class와 같이 두가지 방법이 있습니다.

  직접 태그 내에서 객체를 선언하여 바인딩하는 방법이 있고,
  ```html
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  ```
  ```javascript 
  data() {
    return {
      activeColor: 'red',
      fontSize: 30
    }
  }
  ```

  템플릿을 더 깔끔하게 만들기 위해, 스타일 객체를 따로 만들어 바인딩하는 방법이 있습니다.

  ```html
  <div :style="styleObject"></div>
  ```
  ```javascript 
  data() {
    return {
      styleObject: {
        color: 'red',
        fontSize: '13px'
      }
    }
  }
  ```

  <br>
  <b>2) 배열로 전달하기</b>
  
  배열 구문을 사용하면, 동일한 요소에 다음과 같이 여러 스타일 객체를 적용 할 수 있습니다.
  ```html
  <div :style="[baseStyles, overridingStyles]"></div>
  ```
  <br>
  :class와 동일하게 :style도 삼항 연산자를 활용하여 렌더링 할 수 있습니다.
    ```html
  <div :style="[isOveride ? overridingStyles : baseStyles, textStyles ]"></div>
  ```
  > textSytles는 기본으로 적용되고, isOveride의 값이 true일 경우 overridStyles를, false일 경우 baseStyle를 적용합니다.
  
  추가적으로 다중값을 선언하여 브라우저의 따라 지원하는 배열의 마지막 값만 렌더링해줄 수 있습니다.<br>
  ```html
  <div :style="{ display: [ '-webkit-box', '-ms-flexbox', 'flex' ] }"></div>
  ```
  <br>
* <b>:src, :href</b>

  :src와 :href도 사용법이 간단합니다. :src는 이미지 경로를, :href는 사이트 url을 렌더링 할 수 있습니다.

  ```html
  <img :src="profile" />
  <a :href="url"> test.com </a>
  ```

  ```javascript 
  data() {
    return {
      profile: 'test:/img/profile1.jpg',
      url: 'www.test.com'
    }
  }
  ```

<br>


# 6. v-if, v-show, v-for (렌더링)

  * <b>v-if</b>

    v-if는 조건에 따라 렌더링 할 수 있습니다. <br>
    사용 방법은 간단합니다.

    ```html
    <h1 v-if="awesome">Vue is awesome!</h1>
    <div v-if="Math.random() > 0.5">
      Now you see me
    </div>
    ```
    ```javascript 
    data() {
      return {
        awesome: true;
      }
    }
    ```
    위와 같이 v-if 안에 들어가는 값이 boolean이어야 하고, 변수를 넣어도 가능하고, 조건식을 넣는 것도 가능합니다.<br>
    boolean을 return하는 method 또한 가능하며, computed와 watch로도 사용가능합니다.<br>

    v-if를 사용하게 되면 그에 반대에 한하는 조건에 따라 렌더링 해주는 v-else와 렌더링 조건을 추가하는 v-else-if도 사용 가능합니다.

    ```html
    <div v-if="type === 'A'">
      A
    </div>
    <div v-else-if="type === 'B'">
      B
    </div>
    <div v-else-if="type === 'C'">
      C
    </div>
    <div v-else>
      Not A/B/C
    </div>
    ```
  <br>
    v-if는 디렉티브이기 때문에 하나의 엘리먼트에 추가 되어야 합니다. <br>
    따라서 div를 사용하지 않고 여러 개의 엘리먼트를 전환할 경우 template 태그를 사용하여 감쌉니다.
    ```html
    <template v-if="ok">
      <h1>Title</h1>
      <p>Paragraph 1</p>
      <p>Paragraph 2</p>
    </template>
    ```
    
  * <b>v-show</b>
  
    v-shows는 v-if와 유사하게 조건에 따라 엘리먼트를 표시하는 방식이며, 사용 방법은 거의 동일합니다.

    ```html
    <h1 v-show="ok">Hello!</h1>
    ```
  <br>
    v-if와 v-show는 큰 차이가 있습니다.<br>
    v-if는 초기 렌더링 시 조건이 거짓이면 참이 될 때까지 아무 작업도 하지 않습니다. <br>
    v-show는 조건과 관계없이 무조건 렌더링되고, 조건에 따라 css display:block / display:none 속성을 전환합니다.<br><br>
    따라서 무언가를 자주 전환해야 한다면 v-show를 사용하는 게 좋고, 런타임 시 조건이 변경되지 않는다면 v-if를 사용하는 게 좋습니다.
  <br>
  * <b>v-for</b>
    
    <b>1) 배열 렌더링</b>

    v-for는 배열을 기반으로 리스트를 렌더링 할 수 있습니다.<br>
    사용방법은 다음과 같습니다.

    ```html
    <ul id="array-with-index">
      <li v-for="(item, index) in items" :key="index">
        {{ parentMessage }} - {{ index }} - {{ item.message }}
      </li>
    </ul>
    ```
    ```javascript
    Vue.createApp({
      data() {
        return {
          parentMessage: 'Parent',
          items: [{ message: 'Foo' }, { message: 'Bar' }]
        }
      }
    }).mount('#array-with-index')
    ```
    item은 items의 배열 엘리먼트의 별칭이고, index는 배열 엘리먼트의 인덱스 값입니다.<br>
    in 대신 of도 사용 가능합니다.
  
    > :key에 고유값(id 또는 index)을 설정하는 것을 권장하고 있습니다. (미설정 시 에러 메시지 발생함)<br>
    > v-for는 배열의 값이 추가, 삭제, 정렬, 수정될 경우에 맞춰서 렌더링됩니다.<br>

    <b>2) 객체 렌더링</b>

    v-for를 사용하여 객체의 속성을 반복할 수도 있습니다.

    ```html
      <ul id="v-for-object" class="demo">
        <li v-for="(value, name, index) in myObject" :key="index">
          {{ index }}. {{ name }}: {{ value }}
        </li>   
      </ul>
      <ul id="v-for-number">
        <li v-for=" n in 10" :key="n">
            {{ n }}
        </li>
      </ul>
    ```

    ```javascript
      Vue.createApp({
        data() {
          return {
            myObject: {
              title: 'How to do lists in Vue',
              author: 'Jane Doe',
              publishedAt: '2020-03-22'
            }
          }
        }
      }).mount('#v-for-object')
    ```

    value는 속성 값, name은 속성명(키), index는 해당 속성의 인덱스값을 의미합니다.<br>
    v-for는 배열, 객체뿐만 아니라 정수도 사용 가능합니다.
    
    <br>
    v-for도 template 태그를 활용하여 여러 요소의 블록을 렌더링 할 수 있으며,

    ```html
    <ul>
      <template v-for="item in items">
        <li>{{ item.msg }}</li>
        <li class="divider" role="presentation"></li>
      </template>
    </ul>
    ```

    component에도 적용할 수 있습니다.
    ```html
    <div id="todo-list-example">
      <form v-on:submit.prevent="addNewTodo">
        <label for="new-todo">Add a todo</label>
        <input
          v-model="newTodoText"
          id="new-todo"
          placeholder="E.g. Feed the cat"
        />
        <button>Add</button>
      </form>
      <ul>
        <todo-item
          v-for="(todo, index) in todos"
          :key="todo.id"
          :title="todo.title"
          @remove="todos.splice(index, 1)"
        ></todo-item>
      </ul>
    </div>
    ```
    ```javascript
    const app = Vue.createApp({
      data() {
        return {
          newTodoText: '',
          todos: [
            {
              id: 1,
              title: 'Do the dishes'
            },
            {
              id: 2,
              title: 'Take out the trash'
            },
            {
              id: 3,
              title: 'Mow the lawn'
            }
          ],
          nextTodoId: 4
        }
      },
      methods: {
        addNewTodo() {
          this.todos.push({
            id: this.nextTodoId++,
            title: this.newTodoText
          })
          this.newTodoText = ''
        }
      }
    })

    app.component('todo-item', {
      template: `
        <li>
          {{ title }}
          <button @click="$emit('remove')">Remove</button>
        </li>
      `,
      props: ['title']
    })

    app.mount('#todo-list-example')
    ```
    > 단 반복할 데이터를 컴포넌트로 전달하려면 props를 사용해야 합니다. 
    > props에 대한 설명은 해당 파트에서 진행하도록 하겠습니다.

<br>

# 7. 이벤트 핸들링(v-on)

  v-on 디렉티브는 @ 기호로 축약하여 사용하며, DOM 이벤트를 듣고 트리거 될 때와 javascript를 실행할 때 사용합니다.

  ```html
  <div id="basic-event">
  <button @click="counter += 1">Add 1</button>
  <p>The button above has been clicked {{ counter }} times.</p>
  </div>
  ```
  
  ```javascript
  Vue.createApp({
    data() {
      return {
        counter: 1
      }
    }
  }).mount('#basic-event')
  ```

## 메소드 이벤트
  
  복잡한 로직의 경우 이벤트 속성 값으로 할당하는 것은 지저분하고 오류를 범할 수 있습니다. <br>
  따라서 메소드를 사용하여 이벤트 처리를 할 수 있습니다.

  ```html
  <div id="event-with-method">
    <!-- `greet`는 메소드 이름으로 아래에 정의되어 있습니다 -->
    <button @click="greet">Greet</button>
  </div>
  ```
  
  ```javascript
  Vue.createApp({
    data() {
      return {
        name: 'Vue.js'
      }
    },
    methods: {
      greet(event) {
        // 메소드 안에서 사용하는 `this` 는 Vue 인스턴스를 가리킵니다.
        alert('Hello ' + this.name + '!')
        // `event` 는 네이티브 DOM 이벤트입니다
        if (event) {
          alert(event.target.tagName)
        }
      }
    }
  }).mount('#event-with-method')
  ```

## 인라인 메소드 핸들러 
  
  인라인 javascript 메소드 호출도 가능합니다.
  ```html
  <div id="inline-handler">
    <button @click="say('hi')">Say hi</button>
    <button @click="say('what')">Say what</button>
  </div>
  ```
    
  ```javascript
  Vue.createApp({
    methods: {
      say(message) {
        alert(message)
      }
    }
  }).mount('#inline-handler')
  ```

## 복합 이벤트 

  연산자를 사용하여 이벤트 핸들러 안에서 복합 메소드를 지정할 수 있습니다:

  ```html
  <button @click="one($event), two($event)">
    Submit
  </button>
  ```
    
  ```javascript
  Vue.createApp({
   methods: {
    one(event) {
      // 첫번째 핸들러 로직...
    },
    two(event) {
      // 두번째 핸들러 로직...
    }
  }).mount('#inline-handler')
  ```

## 이벤트 수식어
## 키 수식어
## 시스템 수식어

# 8. form 입력 바인딩

# 9. 컴포넌트

## 컴포넌트 개념

## 컴포넌트 사용 방법

## 컴포넌트 통신 방법

- <b>Props</b>

- <b>Event Emit</b>

# 10. 트랜지션 & 애니메이션
  ## 진입 / 진출

  ## 리스트

  ## 상태

# 11. Composition API
 composition api는 vue3의 가장 핵심적인 부분이며, vue2와 가장 큰 차이점이기도 합니다.<br>
